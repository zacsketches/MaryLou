Bill of Materials:
     Glow Worm robotics framework
     Arduino Due
     Arduino Motor Shield
     Pololu 10 DOF IMU v2
     XBEE
     3-cell lipo battery
     2 x Pololu 37D mm 19:1 gearmotor
     2 x Pololu stamped Al L-Bracket for 37D mm gearmotors
     2 x Pololu universal mounting hubs
     2 x Pololu ?? x 8mm wheels
     4 x 3/4" nylon standoffs
     custom power and signal distribution board
     

1. Start here on Due and motor shield
     http://arduino.cc/en/Tutorial/DueMotorShieldDC

2. Great ref for quadrature encoding
    http://letsmakerobots.com/node/24031

3. The plant will need to attach two encoder motors and
subscribe to the control_effort message.  It will
publish a plant status message with the following fields
    long rt_ct
    float rt_I //mv
    long lt_ct
    float lt_I
    uint32_t timestamp   //microseconds
    
5. Consider having the plant balance counts between the
two motors.
    
4. The attitude computer will pointers to an accel object 
and a magnetometer object, and will need to publish a message
called pitch with the following data:
    int theta    //pitch neg falling back, pos frwd
    uint32_t timestamp   //microseconds
    
5. The state observer will subscribe to the 
pitch message and the plant_status_msg and publish
the state_vec_msg with the following fields
    double theta
    double theta_dot
    double x
    double x_dot
    
6. The balance regulator will subscribe to the 
state_vec_msg and publish the control_effort_msg
with the following field:
    int u
    
7. Have clearinghouse use publish_serial on the
messages of interest for debugging.

8. //Physical connections
const int lt_dir_pin = 12;
const int lt_pwm_pin = 3;
const int lt_sense_pin = A0;
const int lt_encoder_A_pin = 7;
const int lt_encoder_B_pin = 6;

const int rt_dir_pin = 13;
const int rt_pwm_pin = 11;
const int rt_sense_pin = A1;
const int rt_encoder_A_pin = 5;
const int rt_encoder_B_pin = 4;

9. Outstanding resource for IMU info:
     https://code.google.com/p/ardu-imu/wiki/Theory
     
10. The atan or atan2 function is used to calculate pitch
angle directly from the accelerometer.  The Freescale 
Application Note 3461 gives an outstanding explanation of
this.  See AN3461 in the Datasheets folder of the 
project.

11. The atan and atan2 functions resolve their 
result with differing rules about quadrants.  In 
essence atan give a result only in quadrant I or IV.
Whereas atan2 solves for the result in all four 
quadrants.  See this link for a thorough explanation:
    http://stackoverflow.com/questions/283406/what-is-the-difference-between-atan-and-atan2-in-c
    
12. Used basic technique for PI controller tuning with ideas
from Zeiger-Nichols method.  See here for an overview:
     http://en.wikipedia.org/wiki/Ziegler%E2%80%93Nichols_method


    

